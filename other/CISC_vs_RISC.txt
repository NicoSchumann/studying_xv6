x86-64 vs RISC (ARM / RISC-V) — which is best to learn on?
Short answer

Both architectures are valuable for learning. The choice depends on your goals and the trade‑offs you’re willing to make.

x86‑64 (CISC / Intel SDM)

Pros:

Ubiquitous in real‑world desktops and servers.

Beneficial for debugging kernels, reverse engineering, and performance tuning.

The Intel Software Developer’s Manual (SDM) is authoritative and comprehensive.

Cons:

Contains many historical corner cases (e.g., segmentation legacy, numerous control registers).

Instruction encodings can be complex and quirky.

Slower to grasp as a first instruction set architecture (ISA) because of its complexity.

RISC (RISC‑V / ARMv8)

Pros:

Cleaner ISA with simpler decoding and exception handling.

Easier to learn core concepts like registers, load/store operations, branching, and traps.

RISC‑V is open and designed for educational purposes.

ARM is widely used in phones and single-board computers (e.g., Raspberry Pi).

Cons:

ARMv8 introduces its own complexity (exception levels, many system registers).

RISC‑V’s ecosystem is less mature compared to x86‑64, though it’s growing quickly.

Recommendation (practical)

If your goal is to build small Unix‑like kernels and gain a deep understanding of CPU–software interaction, a hybrid approach works well:

Begin with a simple RISC platform (RISC‑V or minimal ARM).

Use it for your initial labs on booting, basic context switches, and page tables.

The simpler architecture makes it easier to grasp fundamental concepts.

Transition to x86‑64 for deeper, real‑world details.

Once you’re comfortable with the basics, move to x86‑64 to learn about legacy features, detailed hardware behavior, and common pitfalls.

The Intel SDM will be an invaluable reference during this phase.

This combination gives you rapid wins from the clean RISC environment and prepares you for production‑grade complexities found in x86‑64.
